<?php
/**
 * @file
 * Module file for services_auth_keys module.
 */

/**
 * Implements hook_services_authentication().
 */
function services_auth_keys_services_authentication_info() {
  return array(
    'file'             => 'services_auth_keys.inc',
    'title'            => t('Access Keys authentication'),
    'description'      => t('Access keys parameter are specified'),
    'authenticate_call' => '_services_auth_keys_authenticate_call',
    'default_security_settings' => '_services_auth_keys_default_security_settings',
    'security_settings' => '_services_auth_keys_security_settings',
  );
}

/**
 * Implements hook_menu().
 */
function services_auth_keys_menu() {
  return array(
    'user/%user/services-keys' => array(
      'title' => 'Services Keys',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('services_auth_keys_user_form', 1),
      'access callback' => 'services_auth_keys_access',
      'access arguments' => array(1),
      'type' => MENU_LOCAL_TASK,
      'file' => 'services_auth_keys.inc',
    ),
  );
}

/**
 * Implements hook_admin_paths().
 */
function services_auth_keys_admin_paths() {
  return array(
    'user/*/services-keys' => TRUE,
  );
}

/**
 * Implements hook_permission().
 */
function services_auth_keys_permission() {
  return array(
    'services use keys authentication' => array(
      'title' => t('Use keys authentication'),
      'description' => t('Allow the user to access services authenticated by its own keys.'),
    ),
    'services manage own authentication keys' => array(
      'title' => t('Manage own authentication keys'),
      'description' => t('Allow the user to see and change its own authentication keys.'),
    ),
  );
}

/**
 * Access callback for the token management page.
 *
 * @global object $user
 *   The current user
 *
 * @param object $account
 *   The user being managed
 *
 * @return bool
 *   TRUE if access, FALSE otherwise
 */
function services_auth_keys_access($account) {
  if (user_access('administer users')) {
    return TRUE;
  }
  else {
    global $user;
    return $user->uid == $account->uid && user_access('services manage own authentication keys');
  }
}

/**
 * Get the keys data based on user ID.
 *
 * @param int $uid
 *   User ID
 *
 * @param bool $raw_value
 *   If set to TRUE, the raw token string will be returned
 *
 * @return mixed
 *   Array with keys data, or raw service string, FALSE if not found.
 */
function services_auth_keys_load_by_user($uid, $raw_value = FALSE) {
  $results = db_select('services_auth_keys', 's')
    ->fields('s')
    ->condition('uid', $uid)
    ->execute();
  if ($results) {
    $keys = array();
    foreach ($results as $result) {
      $keys[$result->service_endpoint] = $result;
    }
    return $keys;
  }
  return FALSE;
}

/**
 * Get the keys data or uid based on keys.
 *
 * @param array $keys
 *   Keys array : key => value.
 *
 * @param bool $raw_value
 *   If set to TRUE, the raw user ID will be returned.
 *
 * @return mixed
 *   Array with keys data, or raw user ID, FALSE if not found.
 */
function services_auth_keys_load_by_keys($keys, $service_endpoint = NULL, $raw_value = FALSE) {
  $query = db_select('services_auth_keys', 's');
  $query->fields('s');
  foreach ($keys as $key => $value) {
    $query->condition($key, $value);
  }
  if (!empty($service_endpoint)) {
    $query->condition('service_endpoint', $service_endpoint);
    $result = $query->execute();
    $result = $result->fetchAssoc();
  }
  else {
    $results = $query->execute();
    foreach ($results as $result) {
      $keys[] = $result;
    }
    return $keys;
  }

  if ($result) {
    return $raw_value ? $result['uid'] : $result;
  }
  return FALSE;
}

/**
 * Update the token string for a given user (or remove it).
 *
 * @param int $uid
 *   User ID
 * @param string $service_endpoint
 *   Service endpoint name
 * @param bool $clear
 *   If set to TRUE, the token will be removed instead of updated.
 */
function services_auth_keys_update_apikeys($uid, $service_endpoint, $apikeys = array('api_key', 'token', 'extra_key')) {
  // Generate API keys.
  do {
    foreach ($apikeys as $apikey) {
      $apikey_value_callback = 'services_auth_keys_generate_' . $apikey;
      $apikeys_values[$apikey] = $apikey_value_callback($uid, $service_endpoint);
    }
  }
  while (services_auth_keys_load_by_keys($apikeys_values, $service_endpoint));
  $query_fields = array(
    'uid' => $uid,
    'service_endpoint' => $service_endpoint,
    'updated' => time(),
  ) + $apikeys_values;
  $query = db_merge('services_auth_keys')
    ->key(array(
      'uid' => $uid,
      'service_endpoint' => $service_endpoint,
    ))
    ->fields($query_fields)
    ->execute();
  module_invoke_all('services_auth_keys_update', $uid, $service_endpoint, $apikeys);
}

/**
 * Delete the API keys for a given user (and service endpoint).
 *
 * @param int $uid
 *   User ID
 * @param string $service_endpoint
 *   Service endpoint name
 */
function services_auth_keys_delete_apikeys($uid, $service_endpoint = NULL) {
  $delete_query =  db_delete('services_auth_keys')
    ->condition('uid', $uid);
  if (!empty($service_endpoint)) {
    $delete_query->condition('service_endpoint', $service_endpoint);
  }
  $delete_query->execute();
  module_invoke_all('services_auth_keys_delete', $uid, $service_endpoint);
}

/**
 * Generates a pseudo-unique api key string based on user data and service name.
 */
function services_auth_keys_generate_api_key($uid, $service_endpoint) {
  global $base_url;
  $string = $base_url . $service_endpoint . $uid . microtime(TRUE);
  return drupal_hash_base64($string);
}

/**
 * Generates a pseudo-unique api key string based on user data and service name.
 */
function services_auth_keys_generate_token($uid, $service_endpoint) {
  $account = user_load($uid);
  $string = $service_endpoint . $account->mail . microtime(TRUE);
  return drupal_hash_base64($string);
}

/**
 * Generates a pseudo-unique extra key string based on user data and service name.
 */
function services_auth_keys_generate_extra_key($uid, $service_endpoint) {
  $account = user_load($uid);
  $string = $service_endpoint . $account->name . microtime(TRUE);
  return drupal_hash_base64($string);
}